input BuySellCoinInput {
  buyingCoin: String!
  quantity: Float
  sellingCoin: String!
  price: Float
}
type Conversion {
  buyingCoin: String!
  quantity: Float
  sellingCoin: String!
  price: Float!
  fees: Float
  expires: Date!
}
input CompletedInput {
  from_uuid: String
  limit: Float
}
enum Status {
  CONVERTING
  COMPLETE
}
type Tick {
  base: String!
  rel: String!
  token_id: String
  symbol: String!
  lastPrice: Float!
  timestamp: Date!
}
type Symbol {
  base: String!
  rel: String!
  symbol: String!
  decimals: Float
  precision: Float
  last: Float!
  lastPrice: Float
  timestamp: Date!
}
type Market {
  coin: String!
  relationships: [Symbol!]
  timestamp: Date!
}
type OrderStatus {
  orderId: String!
  status: Status!
  bought: Float
  sold: Float
  price: Float
  quantity: Float
}

type OpenOrderItem {
  orderId: String!
  quantity: String!
  name: String!
  description: String!
  image: String!
  price: Float!
  timestamp: Date!
}

input BuyItemInput {
  tokenId: String!
  sellingCoin: String!
  buyingCoin: String!
  quantity: Float
  price: Float
}

input SellItemInput {
  tokenId: String!
  price: Float!
  quantity: Float!
  sellingCoin: String!
  buyingCoin: String!
}
type CoinResponse {
  address: String!
  ticker: String!
}
input GetPriceInput {
  base: String!
  tokenId: String
  rel: String!
  quantityBase: Float!
  buyOrSell: String!
}
type Price {
  base: String!
  rel: String!
  token_id: String
  symbol: String!
  price: Float!
  quantity: Float
  timestamp: Date!
  usdValue: Float!
}
type Fee {
  coin: String!
  amount: Float!
  usdAmount: Float
  token_id: String
}
type GetPriceResponse {
  price: Price!
  fees: Fee!
}
enum SortDirection {
  ascending
  descending
}
input ItemQueryInput {
  base: String!
  rel: String!
  nftBaseId: String
  tokenId: String
  userId: String
  sortBy: String
  direction: SortDirection
}
type ExchangeItem {
  id: String
  game: String!
  name: String!
  nftBaseId: String!
  coin: String!
  description: String
  image: String!
  icon: String!
  quantity: Int
  avgPrice: Float
  properties: ItemProperties
  items: [UniqueItem]
}
type ItemProperties {
  game: String
  farmbot: ItemPropertiesFarmbot
  rarity: GameItemRarity
}
type ItemPropertiesFarmbot {
  requiredQty: Int
}
type UniqueItem {
  token_id: String
  nftBaseId: String!
  seller: String!
  dateListed: Date
  listPrice: Float
  orderId: String!
}
input PendingInput {
  base: String
  rel: String
  tokenId: String
}
type UserItemsSold {
  count: Int!
  items: [ItemSold!]
}
type ItemSold {
  image: String!
  name: String!
  coin: String!
  dateSold: Date!
  salePrice: Float!
}
type MarketHighLow {
  high: String
  low: String
  coin: String
}
type Query {
  markets: [Market!]!
  ticks: [Tick!]!
  status(orderId: String!): Status!
  pricesAndFees(getPriceInput: GetPriceInput!): GetPriceResponse!
  completed(filter: CompletedInput): [OrderStatus!]
  pending(pendingInput: PendingInput): [OrderStatus!]
  items(buySellCoin: BuySellCoinInput!): [OpenOrderItem!]
  buyStatus(orderId: String!): OrderStatus!
  sellStatus(orderId: String!): OrderStatus!
  listedGameItems(itemQueryInput: ItemQueryInput): [ExchangeItem!]
  userItemsSold: UserItemsSold!
  userItemsPurchased: UserItemsSold!
  marketHighLow(nftBaseId: String!): MarketHighLow
}
type Mutation {
  coin(buySellCoin: BuySellCoinInput!, walletPassword: String!): OrderStatus!
  cancelConvert(orderId: String!, walletPassword: String!): OrderStatus!
  buy(buyItemInput: BuyItemInput!, walletPassword: String!): OrderStatus!
  sell(sellItemInput: SellItemInput!, walletPassword: String!): OrderStatus!
  sellMany(
    sellManyItemInput: [SellItemInput!]!
    walletPassword: String!
  ): [OrderStatus!]!
  cancelItem(orderId: String!, walletPassword: String!): OrderStatus!
}
